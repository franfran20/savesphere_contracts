// SPDX-License-Identifier: MIT

pragma solidity 0.8.21;

// Oz's Imports
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title SaveSphere: Flex Save Contract
 * @author E.Francis
 * @notice Flex Save allows user to open up a possible flexible savings where they can save for a period of time while earning
 * interest whilst still allowing the user to break the save at any point in case of an emergency
 */
contract FlexSave is ReentrancyGuard {
    // ERRORS
    error FlexSave__AlreadyHasActiveSavings();
    error FlexSave__NoActiveSavings();
    error FlexSave__SavingTimeCompletedAlready();
    error FlexSave__AmountCannotBeZero();
    error FlexSave__TimeCannotBeZero();

    // EVENTS
    event FlexSaveStarted(address user, uint256 amount, uint256 startTime, uint256 stopTime, string reason);
    event FlexSaveToppedUp(address user, uint256 topUpAmount, uint256 topUpTime);
    event SavingsClaimed(address user, uint256 amountClaimed, bool completed);

    // TYPES

    /**
     * Keeps track of the flex saving details of all user combined
     * totalAmountSaved -  total amount saved by all active savers
     * completedTimeSaved - the time sum of time for all users who completed their savings
     * possibleSavingTime - the sum total time of all active savers
     * totalSavers - the total active savers
     * defaultPool - the amount of interest to be shared by all active savers, generated by past defaulters
     * defaultFee - the default fee for all savers on default
     */
    struct TopLevelSavingsDetails {
        uint256 totalAmountSaved;
        uint256 completedTimeSaved;
        uint256 possibleSavingTime;
        uint256 totalSavers;
        uint256 defaultPool;
        uint256 defaultFee;
    }

    /**
     * Keeps track of an inidividual savings details
     * reason - the reason for the savings
     * amount - the amount saved
     * starttime - the start time of the savings
     * stopTime - the stop time of the savings
     * status - the status of the savings, whether the user has an active saving or not
     */
    struct UserSavings {
        string reason;
        uint256 amount;
        uint256 startTime;
        uint256 stopTime;
        bool status;
    }

    // STORAGE
    uint256 constant PERCENT = 100;
    TopLevelSavingsDetails topLevelSavingsDetails;
    IERC20 public MTRG;

    mapping(address user => UserSavings) _userSavings;

    /**
     *
     * @param _amount The mtrg amout sent with the tx
     */
    modifier amountNotZero(uint256 _amount) {
        if (_amount == 0) {
            revert FlexSave__AmountCannotBeZero();
        }
        _;
    }

    /**
     * @param _mtrg the address of the MTRG token
     * @param _defaultFee the default fee for all users who break their savings earlier than expected
     */
    constructor(address _mtrg, uint256 _defaultFee) {
        MTRG = IERC20(_mtrg);
        topLevelSavingsDetails.defaultFee = _defaultFee;
    }

    // EXTERNAL FUNCTIONS

    /**
     * Starts the users flex save with the provided paramaters
     * @param _amount the amount of MTRG to start the savings with
     * @param _time the time in seconds the user wishes to save for
     * @param _reason the reason behind the savings
     */
    function startSave(uint256 _amount, uint256 _time, string memory _reason)
        external
        nonReentrant
        amountNotZero(_amount)
    {
        if (_userSavings[msg.sender].status) {
            revert FlexSave__AlreadyHasActiveSavings();
        }
        if (_time == 0) {
            revert FlexSave__TimeCannotBeZero();
        }

        SafeERC20.safeTransferFrom({token: MTRG, from: msg.sender, to: address(this), value: _amount});

        topLevelSavingsDetails.totalAmountSaved += _amount;
        topLevelSavingsDetails.possibleSavingTime += _time;
        topLevelSavingsDetails.totalSavers += 1;

        _userSavings[msg.sender] = UserSavings({
            reason: _reason,
            amount: _amount,
            startTime: block.timestamp,
            stopTime: block.timestamp + _time,
            status: true
        });

        emit FlexSaveStarted(msg.sender, _amount, block.timestamp, block.timestamp + _time, _reason);
    }

    /**
     * User can top up saving details to continue saving for longer or increase the amount they're saving for
     * @param _amount the amount of mtrg to top up svaings with
     * @param _time the time increment on initial savings
     */
    function topUpSave(uint256 _amount, uint256 _time) external nonReentrant amountNotZero(_amount) {
        if (!_userSavings[msg.sender].status) {
            revert FlexSave__NoActiveSavings();
        }
        if (block.timestamp >= _userSavings[msg.sender].stopTime) {
            revert FlexSave__SavingTimeCompletedAlready();
        }

        SafeERC20.safeTransferFrom({token: MTRG, from: msg.sender, to: address(this), value: _amount});

        topLevelSavingsDetails.totalAmountSaved += _amount;
        _userSavings[msg.sender].amount += _amount;

        if (_time > 0) {
            topLevelSavingsDetails.possibleSavingTime += _time;
            _userSavings[msg.sender].stopTime += _time;
        }

        emit FlexSaveToppedUp(msg.sender, _amount, _time);
    }

    /**
     * User can claim savings before or after the stipulated saving period
     * Claiming before the stipulated saving period leads to default fees on savings
     * Claiming after the stipulated saving period leads to interest attached on savings
     */
    function claimSavings() external nonReentrant {
        if (!_userSavings[msg.sender].status) {
            revert FlexSave__NoActiveSavings();
        }
        bool completed = block.timestamp > _userSavings[msg.sender].stopTime ? true : false;

        uint256 claimedAmount;
        if (completed) {
            claimedAmount = _handleUserInterestShare();
        } else {
            claimedAmount = _handleUserDefault();
        }

        _userSavings[msg.sender] = UserSavings({reason: "", amount: 0, startTime: 0, stopTime: 0, status: false});

        emit SavingsClaimed(msg.sender, claimedAmount, completed);
    }

    // INTERNAL FUNCTIONS

    /**
     * Handles the calculation to returns a users savings with the interest accrued
     */
    function _handleUserInterestShare() internal returns (uint256) {
        uint256 userEndInterestShare = getUserEndInterest(msg.sender);
        uint256 userSavingAmount = _userSavings[msg.sender].amount;
        uint256 userAmountPlusInterest = userEndInterestShare + userSavingAmount;

        uint256 userTimeSaved = _userSavings[msg.sender].stopTime - _userSavings[msg.sender].startTime;

        SafeERC20.safeTransfer({token: MTRG, to: msg.sender, value: userAmountPlusInterest});

        topLevelSavingsDetails.totalAmountSaved -= userSavingAmount;
        topLevelSavingsDetails.completedTimeSaved += userTimeSaved;
        topLevelSavingsDetails.possibleSavingTime -= userTimeSaved;
        topLevelSavingsDetails.totalSavers -= 1;
        topLevelSavingsDetails.defaultPool -= userEndInterestShare;

        return userAmountPlusInterest;
    }

    /**
     * Handles the calculation to return a users savings with the default fee taken
     */
    function _handleUserDefault() internal returns (uint256) {
        uint256 userSavingAmount = _userSavings[msg.sender].amount;
        uint256 defaultAmount = (userSavingAmount * topLevelSavingsDetails.defaultFee) / PERCENT;
        uint256 returnAmount = userSavingAmount - defaultAmount;

        uint256 userTimeSaved = _userSavings[msg.sender].stopTime - _userSavings[msg.sender].startTime;

        SafeERC20.safeTransfer({token: MTRG, to: msg.sender, value: returnAmount});

        topLevelSavingsDetails.totalAmountSaved -= userSavingAmount;
        topLevelSavingsDetails.possibleSavingTime -= userTimeSaved;
        topLevelSavingsDetails.totalSavers -= 1;
        topLevelSavingsDetails.defaultPool += defaultAmount;

        return returnAmount;
    }

    // GETTER FUNCTIONS

    /**
     * gets the users interest share value at the end of the users savings
     * @dev this can always fluctuate when we have more defaulters or savers.
     * @param _user the users address
     */
    function getUserEndInterest(address _user) public view returns (uint256) {
        uint256 userAmountSaved = _userSavings[_user].amount;
        uint256 userTimeSaved = _userSavings[_user].stopTime - _userSavings[_user].startTime;

        uint256 totalAmountSaved = topLevelSavingsDetails.totalAmountSaved;
        uint256 totalTimeSaved = topLevelSavingsDetails.possibleSavingTime;

        uint256 userInterestShare;

        if (_userSavings[_user].status) {
            uint256 amountShare = (userAmountSaved * PERCENT) / totalAmountSaved;
            uint256 timeShare = (userTimeSaved * PERCENT) / totalTimeSaved;
            uint256 combinedShare = (amountShare + timeShare) / 2;

            if (topLevelSavingsDetails.defaultPool > 0) {
                userInterestShare = (combinedShare * topLevelSavingsDetails.defaultPool) / PERCENT;
            } else {
                userInterestShare = 0;
            }
        } else {
            userInterestShare = 0;
        }

        return userInterestShare;
    }

    /**
     * Gets the currently accrued interest the user could possibly earn by completing their savings
     * This would always be flexible as more users default and more users save
     * @param _user the users address
     */
    function getUserCurrentInterestAccrued(address _user) public view returns (uint256) {
        uint256 userEndInterestShare = getUserEndInterest(_user);

        uint256 currentInterest;
        uint256 userSaveStartTime = _userSavings[_user].startTime;
        uint256 userSaveStopTime = _userSavings[_user].stopTime;

        if (userEndInterestShare > 0) {
            if (block.timestamp > userSaveStopTime) {
                currentInterest = userEndInterestShare;
            } else {
                uint256 currentTimeSaved = block.timestamp - userSaveStartTime;
                uint256 userExpectedTimeSaved = userSaveStopTime - userSaveStartTime;
                uint256 timeShare = (currentTimeSaved * PERCENT) / userExpectedTimeSaved;

                currentInterest = (timeShare * userEndInterestShare) / PERCENT;
            }
        } else {
            currentInterest = 0;
        }

        return currentInterest;
    }

    /**
     * Returns the users saving details
     * @param _user address of the user
     */
    function getUserSavings(address _user) public view returns (UserSavings memory) {
        return _userSavings[_user];
    }

    /**
     * Gets the top level savings details of all savers
     */
    function getTopLevelSavingsDetails() public view returns (TopLevelSavingsDetails memory) {
        return topLevelSavingsDetails;
    }

    /**
     * Gets the total amount of time in seconds saved by the user
     * @param _user the address of the user
     */
    function getTimeSaved(address _user) public view returns (uint256) {
        uint256 userSaveStartTime = _userSavings[_user].startTime;
        uint256 userSaveStopTime = _userSavings[_user].stopTime;

        if (block.timestamp > userSaveStopTime) {
            return userSaveStopTime - userSaveStartTime;
        } else {
            return block.timestamp - userSaveStartTime;
        }
    }

    /**
     * gets the current time stamp
     */
    function getCurrentTimestamp() public view returns (uint256) {
        return block.timestamp;
    }
}
